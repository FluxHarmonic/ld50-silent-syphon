(define-module (silent-syphon main)
  (import (mesche array)
          (mesche math)
          (mesche list)
          (mesche time)
          (mesche string)
          (substratic font)
          (substratic input)
          (substratic engine)
          (substratic window)
          (substratic physics)
          (substratic texture)
          (substratic renderer)))

(define window (window-create 1280 720 "Silent Syphon"))
(define input-state (input-init window))
(define renderer (renderer-create window))

;; Load game assets
(define bitmap-font (font-load-file "assets/fonts/Thintel.ttf" 75))

(define screen-scale 4.0)

;; Show the window
(window-show window)

;; Get an fps counter
(define current-fps (make-fps-counter))

;;; -- Game --

(define score-total 0)
(define score-current 0)
(define score-scroll-speed 150)
(define total-level-time 0)
(define max-level-time 180)

;;; -- Player --

;; Define some game state
(define player-ship-color (rgb 100 100 255))
(define player-size 150)
(define player-x (- (/ (window-width window) 2) (/ player-size 2)))
(define player-y (- (window-height window) 300))

(define player-vel-x 0)
(define player-vel-y 0)
(define player-move-speed 500)            ; Pixels per second

(define player-sphere (make-sphere player-x player-y (/ player-size 2)))

(define player-shield-amount 1.0)
(define player-energy-amount 1.0)

(define player-energy-depletion 0.01)

(define (update-player time-delta)
  ;; Deplete energy
  (set! player-energy-amount (- player-energy-amount
                                (* player-energy-depletion time-delta)))

  ;; Update player position
  (if (not (equal? 0 player-vel-x))
      (set! player-x (+ player-x (* player-vel-x time-delta))))
  (if (not (equal? 0 player-vel-y))
      (set! player-y (+ player-y (* player-vel-y time-delta)))))

;; Controls:
;; WSAD for directional
;; J for siphoning energy
;; Space to shoot

(define (handle-player-input input-event)
  (if (input-event-key-down? input-event)
      (if (equal? (input-event-key-code input-event) input-key-code-w)
          (set! player-vel-y (- 0 player-move-speed))
          (if (equal? (input-event-key-code input-event) input-key-code-s)
              (set! player-vel-y player-move-speed)
              (if (equal? (input-event-key-code input-event) input-key-code-a)
                  (set! player-vel-x (- 0 player-move-speed))
                  (if (equal? (input-event-key-code input-event) input-key-code-d)
                      (set! player-vel-x player-move-speed)
                      (if (equal? (input-event-key-code input-event) input-key-code-space)
                          (shoot-bullet (+ player-x (/ player-size 2))
                                        (- player-y bullet-size)
                                        (- 0 default-bullet-speed)
                                        default-bullet-damage
                                        'player))))))
      (if (input-event-key-up? input-event)
          (if (or (equal? (input-event-key-code input-event) input-key-code-w)
                  (equal? (input-event-key-code input-event) input-key-code-s))
              (set! player-vel-y 0)
              (if (or (equal? (input-event-key-code input-event) input-key-code-a)
                      (equal? (input-event-key-code input-event) input-key-code-d))
                  (set! player-vel-x 0))))))

;;; -- Enemies --

;; Varieties of enemies
;; - Plain drones that fly in a straight line or at an angle
;; - Enemies with a more fluid movement path
;; - Enemies that fly in a formation

;; This will be adjusted over time
(define enemy-spawn-interval-base 0.5)
(define enemy-spawn-interval-range 3.5)
(define enemy-spawn-interval-scale 1.0)
(define enemy-spawn-time 0)

(define enemy-list '())

(define-record-type enemy
  (fields x
          y
          size
          score
          color
          shield
          sphere
          update-func))

(define drone-speed 250)

(define (spawn-enemy)
  (spawn-drone))

(define (check-for-spawns time-step)
  (set! enemy-spawn-time (+ enemy-spawn-time time-step))
  (if (> enemy-spawn-time
         (+ (* enemy-spawn-interval-range
               (/ (- max-level-time total-level-time)
                  max-level-time))
            enemy-spawn-interval-base))
      (begin
        (set! enemy-spawn-time 0)
        (spawn-enemy))))

(define (update-drone enemy time-step)
  ;; Update position
  (enemy-y-set! enemy (+ (enemy-y enemy) (* drone-speed time-step)))

  ;; Is it time to shoot?
  )

(define (spawn-drone)
  (let ((x (rand-int (- (window-width window) 100)))
        (y -100)
        (size 100))
    (set! enemy-list
          (cons (make-enemy :x x
                            :y y
                            :size size
                            :shield 10
                            :score 100
                            :sphere (make-sphere x y (/ size 2))
                            :color (rgb 234 255 0)
                            :update-func update-drone)
                enemy-list))))

(define (update-enemies time-step)
  (let next-enemy ((enemies enemy-list)
                   (new-enemies '()))
    (if (pair? enemies)
        (let ((enemy (car enemies)))
          ;; Is the enemy still alive?
          (if (> (enemy-shield enemy) 0)
              (begin
                ;; Update the enemy
                ((enemy-update-func enemy) enemy time-step)

                ;; Set the sphere center
                (sphere-center-x-set! (enemy-sphere enemy)
                                      (enemy-x enemy))
                (sphere-center-y-set! (enemy-sphere enemy)
                                      (enemy-y enemy))

                ;; Check if enemy is still on screen
                (if (< (enemy-y enemy)
                       (window-height window))
                    (set! new-enemies (cons enemy new-enemies))))

              ;; Give the player some score
              (set! score-total (+ score-total (enemy-score enemy))))

          (next-enemy (cdr enemies) new-enemies))

        ;; Return the updated enemies list
        new-enemies)))

(define (render-enemies renderer)
  (let next-enemy ((enemies enemy-list))
    (if (pair? enemies)
        (let ((enemy (car enemies)))
          ;; Render the enemy
          (renderer-draw-rect renderer
                              (- (enemy-x enemy)
                                 (/ (enemy-size enemy) 2))
                              (- (enemy-y enemy)
                                 (/ (enemy-size enemy) 2))
                              (enemy-size enemy)
                              (enemy-size enemy)
                              (enemy-color enemy))

          (next-enemy (cdr enemies))))))

;;; -- Bullets --

(define-record-type bullet
  (fields x y
          vel-y
          damage
          sphere
          owner))

(define bullet-color (rgb 255 165 0))
(define bullet-size 20)
(define bullet-list '())
(define default-bullet-speed 700)
(define default-bullet-damage 10)

(define (update-bullets time-delta)
  (let next-bullet ((bullets bullet-list)
                    (new-bullets '())
                    (bullet-alive t))
    (if (pair? bullets)
        (let ((bullet (car bullets)))
          ;; Move the bullet
          (bullet-y-set! bullet (+ (bullet-y bullet)
                                   (* (bullet-vel-y bullet) time-delta)))

          ;; Set the sphere center
          (sphere-center-x-set! (bullet-sphere bullet)
                                (bullet-x bullet))
          (sphere-center-y-set! (bullet-sphere bullet)
                                (bullet-y bullet))

          ;; TODO: Check for collision
          ;; Check for sphere of bullet vs sphere of entity
          (if (equal? (bullet-owner bullet) 'player)
              (let next-enemy ((enemies enemy-list))
                (if (pair? enemies)
                    (begin
                      (if (sphere-intersect? (bullet-sphere bullet) (enemy-sphere (car enemies)))
                          ;; TODO: Make bullet go away
                          (begin
                            (set! bullet-alive nil)
                            (enemy-shield-set! (car enemies)
                                               (- (enemy-shield (car enemies))
                                                  (bullet-damage bullet)))))
                      (next-enemy (cdr enemies))))))

          ;; Check if bullet is still on screen
          (if (and bullet-alive
                   (> (+ (bullet-y bullet) bullet-size) 0))
              (set! new-bullets (cons bullet new-bullets)))

          (next-bullet (cdr bullets) new-bullets t))

        ;; Return the updated bullets list
        new-bullets)))

(define (render-bullets renderer)
  (let next-bullet ((bullets bullet-list))
    (if (pair? bullets)
        (let ((bullet (car bullets)))
          (renderer-draw-rect renderer
                              (- (bullet-x bullet)
                                 (/ bullet-size 2))
                              (- (bullet-y bullet)
                                 (/ bullet-size 2))
                              bullet-size bullet-size
                              bullet-color)
          (next-bullet (cdr bullets))))))

(define (shoot-bullet x y vel-y damage owner)
  (set! bullet-list (cons (make-bullet :x x :y y
                                       :vel-y vel-y
                                       :sphere (make-sphere x y (/ bullet-size 2))
                                       :damage damage
                                       :owner owner)
                          bullet-list)))

;;; -- HUD --

(define hud-width 300)
(define meter-height 300)
(define hud-color (rgb 92 87 85))
(define shield-meter-color (rgb 158 252 255))
(define energy-meter-color (rgb 255 105 41))

(define (update-hud time-step)
  (if (< score-current score-total)
      (set! score-current (min score-total
                               (+ score-current (* score-scroll-speed time-step))))))

(define (render-hud renderer)
  (renderer-draw-rect renderer
                      (- (window-width window) hud-width)
                      0
                      (window-width window)
                      (window-height window)
                      hud-color)

  (let ((shield-meter-height (* player-shield-amount meter-height)))
    (renderer-draw-rect renderer
                        (- (window-width window) 190)
                        (- (- (window-height window) 100)
                           shield-meter-height)
                        40
                        shield-meter-height
                        shield-meter-color))

  (let ((energy-meter-height (* player-energy-amount meter-height)))
    (renderer-draw-rect renderer
                        (- (window-width window) 135)
                        (- (- (window-height window) 100)
                           energy-meter-height)
                        40
                        energy-meter-height
                        energy-meter-color))

  ;; Draw the score
  (render-text renderer
               bitmap-font
               (string-append "Score: " (number->string score-current))
               (- (window-width window) 270)
               150))

;;; -- Input --

(define (handle-input-events)
  (let next-event ((input-event (input-event-take input-state)))
    (if input-event
        (begin
          (handle-player-input input-event)
          (next-event (input-event-take input-state))))))

;;; -- Game Loop --

(define (game-updater time-delta)
  (if (not (window-needs-close? window))
      (begin
        ;; Count how much time we've been in the level
        (set! total-level-time (+ total-level-time time-delta))

        ;; Update the player
        (handle-input-events)
        (update-player time-delta)

        ;; Update bullets
        (set! bullet-list (update-bullets time-delta))

        ;; Spawn and update enemies
        (check-for-spawns time-delta)
        (set! enemy-list (update-enemies time-delta))

        ;; Update the HUD
        (update-hud time-delta)

        ;; Make sure we don't exit the game loop
        t)))

(define (game-renderer renderer)
  ;; Clear the screen
  (renderer-clear renderer 0 0 0)

  ;; Render the player's ship
  (renderer-draw-rect renderer
                      player-x player-y
                      player-size player-size
                      player-ship-color)

  ;; Render the enemies
  (render-enemies renderer)

  ;; Render the bullets
  (render-bullets renderer)

  ;; Render the HUD
  (render-hud renderer)

  ;; Render the FPS
  (let ((fps (current-fps)))
    (if fps
        (render-text renderer
                     bitmap-font
                     (string-append "FPS: " (number->string fps 3))
                     (- (window-width window) 220)
                     60))))

;; This will run the game functions until the updater returns nil
(run-engine-loop :renderer renderer
                 :update-func game-updater
                 :render-func game-renderer)
